<!DOCTYPE html>
<html>
<head>
    <title>Stream Walkers</title>
    <style>
        /* IMPORTANT: Setting background to transparent is crucial for OBS overlay */
        body {
            margin: 0;
            overflow: hidden;
            background: transparent;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const socket = io();

    // Match canvas size to the OBS Browser Source resolution (e.g., 1920x1080)
    canvas.width = 1920;
    canvas.height = 1080;

    const avatars = [];
    const spriteImage = new Image();
    spriteImage.src = 'sprite.png';

    // --- CONFIGURATION ---
    const FRAME_WIDTH = 32;       // Width of a single frame in your sprite.png
    const FRAME_HEIGHT = 50;      // Height of a single frame
    const SCALE = 3;              // Scaling factor for display size
    const DISPLAY_WIDTH = FRAME_WIDTH * SCALE;
    const DISPLAY_HEIGHT = FRAME_HEIGHT * SCALE;
    const WALKING_SPEED = 1;    // Pixels per frame
    const STAGGER_FRAMES = 8;     // How many animation frames pass before the sprite frame changes (lower = faster)
    // ---------------------


    class Avatar {
        constructor(username, color) {
            this.x = Math.random() * (canvas.width - DISPLAY_WIDTH); // Random starting x position
            this.y = canvas.height - DISPLAY_HEIGHT - 10; // Fixed position near the bottom

            const randomSpeedFactor = Math.random() * 1 + 0.5; // Random factor between 0.5 and 1.5
            this.dx = (Math.random() < 0.5 ? 1 : -1) * WALKING_SPEED * randomSpeedFactor; // Random speed and direction

            this.username = username;
            this.color = color;
            this.frameX = 0;
            this.gameFrame = 0;
        }

        update() {
            // Move the avatar
            this.x += this.dx;

            // Bounce off the walls
            if (this.x < 0 || this.x + DISPLAY_WIDTH > canvas.width) {
                this.dx *= -1; // Reverse direction
            }

            // Animate sprite frames
            if (this.gameFrame % STAGGER_FRAMES === 0) {
                this.frameX = (this.frameX + 1) % 3;
            }
            this.gameFrame++;
        }

        draw() {
            // Flip the sprite horizontally if moving left
            ctx.save();
            if (this.dx < 0) {
                ctx.scale(-1, 1);
                ctx.drawImage(spriteImage,
                    this.frameX * FRAME_WIDTH, 0, FRAME_WIDTH, FRAME_HEIGHT,
                    -this.x - DISPLAY_WIDTH, this.y, DISPLAY_WIDTH, DISPLAY_HEIGHT
                );
            } else {
                ctx.drawImage(spriteImage,
                    this.frameX * FRAME_WIDTH, 0, FRAME_WIDTH, FRAME_HEIGHT,
                    this.x, this.y, DISPLAY_WIDTH, DISPLAY_HEIGHT
                );
            }
            ctx.restore();

            // Draw the username
            ctx.fillStyle = this.color;
            ctx.font = `${10 * SCALE}px sans-serif`;
            ctx.textAlign = 'center';

            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeText(this.username, this.x + DISPLAY_WIDTH / 2, this.y - 10);
            ctx.fillText(this.username, this.x + DISPLAY_WIDTH / 2, this.y - 10);
        }
    }

    // Handle incoming new-chatter events from server
    socket.on('new-chatter', (data) => {
        // Check if the user is already walking. If not, spawn a new avatar.
        if (!avatars.find(a => a.username === data.username)) {
            avatars.push(new Avatar(data.username, data.color));
        }
    });

    function animate() {
        // Clear the entire canvas for the next frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update and draw all avatars
        for (let i = avatars.length - 1; i >= 0; i--) {
            const avatar = avatars[i];
            const shouldRemove = avatar.update();

            if (shouldRemove) {
                avatars.splice(i, 1); // Remove from array if off-screen
            } else {
                avatar.draw();
            }
        }

        // Loop the animation
        requestAnimationFrame(animate);
    }

    // Start animation once the sprite image is guaranteed to be loaded
    spriteImage.onload = animate;

</script>
</body>
</html>